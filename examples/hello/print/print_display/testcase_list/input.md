Реализовать `fmt::Display` для структуры, в которой каждый элемент должен обрабатываться последовательно не так то просто. Проблема в том, что `write!` каждый раз возвращает `fmt::Result`.
Правильная обработка `fmt::Result` требует работы с *каждым* результатом.
Для подобных случаев Rust предоставляет макрос `try!`.

Использование `try!` для `write!` выглядит следующим образом:

```rust
// Попробуй исполнить `write!`, чтобы узнать, вернется ли ошибка. Если ошибка, верни ее.
// Если нет, то продолжи.
try!(write!(f, "{}", value));
```

С помощью макроса `try!` реализация `fmt::Display` для `Vec` довольно простая:

{testcase_list.play}

### Задание

Попробуйте изменить программу так, чтобы индекс элемента так же выводился в консоль. Новый вывод должен выглядеть примерно вот так:

```rust
[0: 1, 1: 2, 2: 3]
```


### Смотрите также

[`for`][for], [`ref`][ref], [`Result`][result], [`struct`][struct],
[`try!`][try], и [`vec!`][vec]

[for]: /flow_control/for.html
[result]: /std/result.html
[ref]: /scope/borrow/ref.html
[struct]: /custom_types/structs.html
[try]: /std/result/try.html
[vec]: /std/vec.html
