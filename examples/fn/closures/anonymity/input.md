Замыкания временно захватывают переменные из окружающих областей видимости.
Имеет ли это какие-либо последствия? Конечно. Как видите, использование
замыкания в аргументах функции требует [обобщённых типов][generics] из-за
особенностей реализации замыканий:

```rust
// `F` должен быть обобщённым типом.
fn apply<F>(f: F) where
    F: FnOnce() {
    f();
}
```

Во время определения замыкания компилятор неявно создаёт новую анонимную
структуру для хранения захваченных переменных, тем временем реализуя
функциональность для некого неизвестного типа с помощью одного из типажей: `Fn`,
`FnMut`, или `FnOnce`. Этот тип присваивается переменной, которая хранится до
самого вызова замыкания.

Так как этот новый тип заранее неизвестен, любое его использование в функции
потребует обобщённых типов. Тем не менее, неограниченный параметр типа `<T>`
по прежнему будет неоднозначным и недопустим. Таким образом, ограничение по
одному из типажей: `Fn`, `FnMut`, или `FnOnce` (которые он реализует) необходимо
для использования этого типа.

{anonymity.play}

### Смотрите также:

[Подробный разбор][thorough_analysis], [`Fn`][fn], [`FnMut`][fn_mut],
and [`FnOnce`][fn_once]

[generics]: ../../generics.html
[fn]: https://doc.rust-lang.org/std/ops/trait.Fn.html
[fn_mut]: https://doc.rust-lang.org/std/ops/trait.FnMut.html
[fn_once]: https://doc.rust-lang.org/std/ops/trait.FnOnce.html
[thorough_analysis]: https://huonw.github.io/blog/2015/05/finding-closure-in-rust/
