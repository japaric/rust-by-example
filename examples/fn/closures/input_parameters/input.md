В то время как замыкания Rust выбирают способ захвата переменных на лету, по
большей части без указания типов, эта двусмысленность недопустима при написании
функций. При использовании замыкания в качестве входного параметра, его тип
должен быть указан с использованием одного из `типажей`. Вот они, в порядке
уменьшения ограничений:

* `Fn`: замыкание захватывает по ссылке (`&T`)
* `FnMut`: замыкание захватывает по изменяемой ссылке (`&mut T`)
* `FnOnce`: замыкание захватывает по значению (`T`)

Компилятор стремится захватывать переменные наименее ограничивающим способом.

Для примера, рассмотрим аргумент, указанный как `FnOnce`. Это означает, что
замыкание *может* захватывать `&T`, `&mut T`, или `T`, но компилятор в итоге
будет выбирать в зависимости от того, как захваченные переменные используются
в замыкании.

Это связано с тем, что если перемещение возможно, тогда любой тип заимствования
также должен быть возможен. Отметим, что обратное не верно. Если параметр
указан как `Fn`, то захват переменных как `&mut T` или `T` недопустим.

В следующем примере попробуйте поменять местами использование `Fn`, `FnMut`, и
`FnOnce`, чтобы увидеть результат.

{input_parameters.play}

### Смотрите также:

[`std::mem::drop`][drop], [`Fn`][fn], [`FnMut`][fnmut], и [`FnOnce`][fnonce]

[drop]: https://doc.rust-lang.org/std/mem/fn.drop.html
[fn]: https://doc.rust-lang.org/std/ops/trait.Fn.html
[fnmut]: https://doc.rust-lang.org/std/ops/trait.FnMut.html
[fnonce]: https://doc.rust-lang.org/std/ops/trait.FnOnce.html
