Чтобы связать контейнер с новой библиотекой, нужна декларация `extern crate`. 
Она не только свяжет библиотеку, но и импортирует все элементы в модуль 
с тем же именем, что и сама библиотека. 
Правила видимости, применимые к модулям, так же применимы и к библиотекам.

{executable.rs}

```
# Где library.rlib путь к скомпилированной библиотеки. Предположим, что
# она находится в той же директории:
$ rustc executable.rs --extern rary=library.rlib && ./executable
вызвана `public_function()` контейнера rary
вызвана `indirect_access()` контейнера rary, которая
> вызывает `private_function()` контейнера rary
```
